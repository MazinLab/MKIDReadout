"""
Author: Alex Walter
Date: March 26, 2018

This code runs a widesweep with the digital readout




Usage:
From command line
$ python digitalWS.py 220 221 -c example.cfg -o filePrefix

From python
>>> digWS = DigitalWideSweep([220,221], 'example.cfg', 'filePrefix')
>>> digWS.startWS(roachNums=[220,221], startFreqs=[3.5E9, 5.5E9], endFreqs=[5.5E9,7.5E9],lo_step=None, DACatten=None, ADCatten=None, widesweepFN='test.txt',makeNewFreqs=True)



"""


import traceback, sys, warnings
from functools import partial
from MkidDigitalReadout.DataReadout.ChannelizerControls.RoachStateMachine import RoachStateMachine
import ConfigParser
from PyQt4 import QtCore
import numpy as np

import matplotlib.pyplot as plt




class DigitalWideSweep(QtCore.QObject):

    def __init__(self, roachNums=None, defaultValues=None, filePrefix=None):
        '''
        Initialize DigitalWideSweep object
        
        INPUTS:
            roachNums - list of roach numbers. ie. [220,221,230,234]
            defaultValues - path to config file. See documentation on ConfigParser
            filePrefix - put this prefix at the beginning of widesweep files generated by this code
        '''
        super(QtCore.QObject, self).__init__()
        #if roachNums is None or len(roachNums) ==0:
        #    roachNums = range(10)
        self.roachNums = np.unique(roachNums)       # sorts and removes duplicates
        self.numRoaches = len(self.roachNums)       # (int) number of roaches connected
        self.config = ConfigParser.ConfigParser()
        if defaultValues is None:
            defaultValues = 'example.cfg'
        self.config.read(defaultValues)
        if filePrefix: self.filePrefix=str(filePrefix)+'_'
        else: self.filePrefix=''

         #Setup RoachStateMachine and threads for each roach
        self.roaches = []
        self.roachThreads=[]
        for i in self.roachNums:
            roach=RoachStateMachine(i,self.config)
            thread = QtCore.QThread(parent=self)                                        # if parent isn't specified then need to be careful to destroy thread
            thread.setObjectName("Roach_"+str(i))                                       # process name
            roach.finishedCommand_Signal.connect(partial(self.catchRoachSignal,i))      # call catchRoachSignal when roach finishes a command
            roach.commandError_Signal.connect(partial(self.catchRoachError,i))          # call catchRoachError when roach errors out on a command
            thread.started.connect(roach.executeCommands)                               # When the thread is started, automatically call RoachStateMachine.executeCommands()
            roach.finished.connect(thread.quit)                                         # When all the commands are done executing stop the thread. Can be restarted with thread.start()
            roach.moveToThread(thread)                                                  # The roach functions run on the seperate thread
            self.roaches.append(roach)
            self.roachThreads.append(thread)
            #self.destroyed.connect(self.thread.deleteLater)
            #self.destroyed.connect(self.roach.deleteLater)

        #parameters for making random freq list
        self.toneBandwidth = 500.0E3   # Hz                                        # frequencies will not be closer together than this to avoid bandwidth overlap
        self.minNominalSpacing = 800.0E3    #Hz                                         # Will fit 1024 frequencies into bandwidth specified or fewer
    

    def catchRoachError(self,roachNum, command, exc_info=None):
        """
        This function is executed when the commandError signal is sent from a RoachThread
        
        INPUTS:
            roachNum - (int) the roach number
            command - (int) the command that finished
            exc_info - from the exception
            
        """
        traceback.print_exception(*exc_info)
        roachArg = np.where(np.asarray(self.roachNums) == roachNum)[0][0]
        print 'Roach ',roachNum,' errored out: ',RoachStateMachine.parseCommand(command)
    
    def catchRoachSignal(self,roachNum,command,commandData):
        """
        This function is executed when the finishedCommand signal is sent from a RoachThread
        
        INPUTS:
            roachNum - (int) the roach number
            command - (int) the command that finished
            commandData - Data from the command. For Example, after sweep it returns a dictionary of I and Q values
        """
        print "Finished r"+str(roachNum)+' '+RoachStateMachine.parseCommand(command)

        if command == RoachStateMachine.SWEEP:
            self.writeWSdata(roachNum, commandData)



    def writeWSdata(self, roachNum, data):
        roachArg = np.where(np.asarray(self.roachNums) == roachNum)[0][0]
        freqFN = self.roaches[roachArg].get('Roach '+str(roach_i),'freqfile')
        path=freqFN.rsplit('/',1)[0]
        widesweepFN = path+'/'+self.filePrefix+'digWS.txt'
        
        freqs=[]
        I = []
        Q = []
        for ch in range(len(data['I'])):    #Could do this faster with numpy tile and reshape...
            freqs.append(data['freqOffsets'] + data['freqList'][ch])
            I.append(data['I'][ch])
            Q.append(data['Q'][ch])
        
        args = np.argsort(freqs)
        
        
        outData = np.asarray([ np.asarray(freqs)[args]/1.E9, np.asarray(I)[args], np.asarray(Q)[args]]).T
        header='Widesweep with Digital Readout:\n'+\
               'Roach#: '+str(roachNum)+'\n'+\
               'freqlist FN: '+self.roaches[roachArg].config.get('Roach '+str(roachNum),'freqfile')+'\n'+\
               'LO [GHz]: '+str(self.roach[roachArg].config.getfloat('Roach '+str(roachNum),'lo_freq')/1.E9)+'\n'+\
               'LO span [MHz]: '+str(self.roaches[roachArg].config.getfloat('Roach '+str(roachNum),'sweeplospan')/1.E6)+'\n'+\
               'LO step [kHz]: '+str(self.roaches[roachArg].config.getfloat('Roach '+str(roachNum),'sweeplostep')/1.E3)+'\n'+\
               'Res atten: '+str(self.roaches[roachArg].roachController.attenList[0])+'\n'+\
               'DAC atten: '+str(self.roaches[roachArg].config.getfloat('Roach '+str(roachNum),'dacatten_start'))+'\n'+\
               'ADC atten: '+str(self.roaches[roachArg].config.getfloat('Roach '+str(roachNum),'adcatten'))
        np.savetxt(outfilename, outData, fmt="%.9f %.9f %.9f",header=header)
        
        
        

    def startWS(self, roachNums=None, startFreqs=None, endFreqs=None,lo_step=None, DACatten=None, ADCatten=None, makeNewFreqs=True, **kwargs):
        """
        This function starts a widesweep on the roaches specified
        
        INPUTS:
            roachNums - The roaches to run a power sweep on. If none, then run all of them
            startFreqs - The starting sweep frequency for each roach. If None then default to 1GHz below LO
            endFreqs - The ending sweep frequency for each roach. If None then default to 1GHz above LO
            lo_step - LO step size. If not given, then uses value in the templar config file
            DACatten - 
            ADCatten - 
            makeNewFreqs - If true, then generate a new random freq file
            **kwargs - additional keywords for makeRandomFreqList()
        """
        if not roachNums:
            roachNums=self.roachNums
        
        for i, roach_i in enumerate(roachNums):
            roachArg = np.where(np.asarray(self.roachNums) == roach_i)[0][0]
            if self.roachThreads[roachArg].isRunning():
                print 'Roach '+str(roach_i)+' is busy'
            else: 
                freqFN = self.roaches[roachArg].config.get('Roach '+str(roach_i),'freqfile')
                LO = self.roach[roachArg].config.getfloat('Roach '+str(roach_i),'lo_freq')
                maxBandwidth = self.roaches[0].roachController.params['dacSampleRate']
                try: startFreq = startFreqs[i]
                except: startFreq=LO - maxBandwidth/2.
                try: endFreq = endFreqs[i]
                except: endFreq=LO + maxBandwidth/2.
                if makeNewFreqs:
                    freqs, LO, span = self.makeRandomFreqList(startFreq, endFreq,**kwargs)
                    path=freqFN.rsplit('/',1)[0]
                    freqFN=path+'/'+'freq_WS_r'+str(roach_i)+'.txt'
                    self.saveFreqList(freqs, freqFN)
                    
                    self.roach[roachArg].config.set('Roach '+str(roach_i),'freqfile',freqFN)
                    self.roach[roachArg].config.set('Roach '+str(roach_i),'lo_freq',str(LO))
                else:
                    freqFN2=freqFN.rsplit('.',1)[0]+'_NEW.'+ freqFN.rsplit('.',1)[1]
                    try: freqData = np.loadtxt(freqFN2)
                    except IOError: freqData=np.loadtxt(freqFN)
                    resIDs = np.atleast_1d(freqData[:,0])
                    freqs = np.atleast_1d(freqData[:,1])
                    self.saveFreqList(freqs, freqFN2, resIDs=resIDs)
                    span = np.amax([freqs[0] - startFreq, endFreq - freqs[-1], np.amax(np.diff(freqs))])
                
                self.roaches[roachArg].config.set('Roach '+str(roach_i),'sweeplospan',str(span))
                if lo_step: self.roaches[roachArg].config.set('Roach '+str(roach_i),'sweeplostep',str(lo_step))
                if DACatten:
                    self.roaches[roachArg].config.set('Roach '+str(roach_i),'dacatten_start',str(DACatten))
                    self.roaches[roachArg].config.set('Roach '+str(roach_i),'dacatten_stop',str(DACatten))
                if ADCatten: self.roaches[roachArg].config.set('Roach '+str(roach_i),'adcatten',str(ADCatten))
                
                self.roaches[roachArg].addCommands(RoachStateMachine.SWEEP)        # add command to roach queue
                self.roachThreads[roachArg].start()
    
    def saveFreqList(self,freqs, outfilename='test.txt', atten=50, resIDs=None):
        attens=[atten]*len(freqs)
        resIDs=range(len(freqs))
        data = np.asarray([resIDs, freqs, attens]).T
        np.savetxt(outfilename, data, fmt="%4i %10.1f %4i")
    
    def makeRandomFreqSideband(self, startFreq, endFreq, nChannels, toneBandwidth, freqResolution):
        if nChannels <1:
            return np.asarray([],dtype=np.int)
        #if nChannels==1:
        #    return np.asarray([startFreq])
        avgSpacing = (endFreq - startFreq)/nChannels
        freqs = np.linspace(startFreq, endFreq, nChannels, False)+avgSpacing/2.
        freqs+= np.random.rand(len(freqs)) * avgSpacing - avgSpacing/2.
        
        #Correct doubles
        for arg in range(len(freqs)-1):
            if (freqs[arg+1] - freqs[arg]) <toneBandwidth:
                if arg==0: f_low =startFreq - toneBandwidth + freqResolution
                else: f_low = freqs[arg -1]
                if arg>=(len(freqs)-2): f_high = endFreq + toneBandwidth - freqResolution
                else: f_high = freqs[arg+2]
                
                f_spacing = (f_high - f_low) / 3.0
                if f_spacing>=toneBandwidth:       #push the two tones between f_high and f_low
                    freqs[arg]=f_low+f_spacing
                    freqs[arg+1]=f_low+2.0*f_spacing
                elif (f_high - f_low) /2.0 >= toneBandwidth:   #push one tone halfway between f_high and f_low
                    freqs[arg]=(f_high - f_low)/2.0
                    freqs[arg+1] = freqs[arg]
                else:                                       #remove both tones
                    freqs[arg] = f_low
                    freqs[arg+1]=f_low
        freqs=np.unique(freqs)
        
        return freqs
    
    def makeRandomFreqList(self, startFreq, endFreq, toneBandwidth=512.0E3, minNominalFreqSpacing=800.0E3):
        """
        This function makes a list of random frequencies in the frequency range specified
        
        INPUTS:
            startFreq - bandwidth to sweep
            endFreq - cannot sweep more than 2 GHz range
            toneBandwidth - minimum distance between freqs to avoid bandwidth overlap
            nominalFreqSpacing - nominal avg distance between freqs. May be forced to go larger to cover freq range
                                 Needs to be at least toneBandwidth+100.*freqResolution
        """
        assert endFreq >= startFreq, "Must use a positive Freq range"
        maxBandwidth = self.roaches[0].roachController.params['dacSampleRate']
        freqResolution = self.roaches[0].roachController.params['dacSampleRate']/(self.roaches[0].roachController.params['nDacSamplesPerCycle']*self.roaches[0].roachController.params['nLutRowsToUse'])
        #print 'freq res:', freqResolution
        #assert (endFreq - startFreq) <= maxBandwidth, "Must use range less than 2 GHz"
        if endFreq - startFreq >maxBandwidth:
            warnings.warn("Must do more than 1 sweep for full frequency range")
            endFreq = startFreq+maxBandwidth
        minNominalFreqSpacing = max(toneBandwidth+100.*freqResolution, minNominalFreqSpacing)
        
        #Determine number of tones needed
        nChannels=self.roaches[0].roachController.params['nChannels']
        avgSpacing = (endFreq - startFreq - toneBandwidth)/nChannels
        if avgSpacing < (minNominalFreqSpacing):
            avgSpacing = minNominalFreqSpacing
            nChannels = int ((endFreq - startFreq-toneBandwidth)/avgSpacing)
        if nChannels<=1:
            nChannels=1
            avgSpacing=0.
            
        LO = (startFreq + endFreq)/2.0 + float(nChannels==1)*(2.0*minNominalFreqSpacing+toneBandwidth/2.)
        maxBandwidth = min( maxBandwidth, max((endFreq - startFreq)+2.0*toneBandwidth, 3.0*toneBandwidth))

        #Make freqList
        freqs_low=self.makeRandomFreqSideband(startFreq+freqResolution, LO-toneBandwidth/2.-freqResolution, np.ceil(nChannels/2.), toneBandwidth, freqResolution)
        freqs_high=self.makeRandomFreqSideband(LO+toneBandwidth/2.+freqResolution, endFreq-freqResolution, np.floor(nChannels/2.), toneBandwidth, freqResolution)
        freqList = np.append(freqs_low, freqs_high)
        
        #freqList = np.rint(freqList).astype(np.int)
        maxSpan = np.amax([(endFreq - startFreq) - (freqList[-1] - freqList[0]), np.amax(np.diff(freqList))])
        offset=freqList[0]-startFreq - maxSpan/2.
        freqList = freqList - offset
        LO = LO - offset
        return freqList, LO, maxSpan


if __name__ == "__main__":
    args = sys.argv[1:]
    defaultValues=None
    filePrefix=None
    if '-c' in args:
        indx = args.index('-c')
        defaultValues=args[indx+1]
        try: args = args[:indx]+args[indx+2:]
        except IndexError:args = args[:indx]
    if '-o' in args:
        indx = args.index('-o')
        filePrefix=args[indx+1]
        try: args = args[:indx]+args[indx+2:]
        except IndexError:args = args[:indx]
    roachNums = np.asarray(args, dtype=np.int)
    print defaultValues,roachNums, filePrefix
    
    digWS = DigitalWideSweep(roachNums, defaultValues,filePrefix)
    
    
    startFreq=3.5E9
    endFreq=5.5E9
    freqs,LO,span=digWS.makeRandomFreqList(startFreq, endFreq)
    digWS.saveFreqList(freqs)
    
    digWS.roaches[0].config.set('Roach '+str(112),'dacatten_stop',str(24))
    with open('test.cfg', 'wb') as configfile:
        digWS.roaches[0].config.write(configfile)
    
    #plt.plot(freqs, [1]*len(freqs),'.')
    #plt.show()

